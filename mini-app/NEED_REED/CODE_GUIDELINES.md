## Перезапуск mini-app
- **Контекст**: сервис `mini-app` запускается через `docker compose` и публикует фронтенд на `:8002`. Перезапуск выполняем точечно, чтобы не трогать остальные контейнеры.
- **Шаги для ARM64 (Raspberry Pi и т. п.)**:
  1. Обновите код (если требуется): `git pull` или скопируйте локальные изменения в том, что смонтировано в контейнер.
  2. Перезапустите только mini-app:  
     ```bash
     docker compose -f docker-compose-arm64.yml up -d mini-app
     ```
     > Команда запустит контейнер в фоне и пересоберёт его, если изменилась `Dockerfile` или зависимости.
  3. Проверьте логи (опционально):  
     ```bash
     docker compose -f docker-compose-arm64.yml logs -f mini-app
     ```
- **Шаги для AMD64/x86_64**: замените файл compose на `docker-compose-amd.yml`:
  ```bash
  docker compose -f docker-compose-amd.yml up -d mini-app
  docker compose -f docker-compose-amd.yml logs -f mini-app
  ```
- **Быстрый рестарт без пересборки** (если нужно просто перечитать конфиг/перезапустить процесс):  
  ```bash
  docker compose -f docker-compose-arm64.yml restart mini-app
  ```
  Для AMD64 замените файл compose аналогично.
- **Проверка статуса**:  
  ```bash
  docker compose -f docker-compose-arm64.yml ps mini-app
  ```
- **CloudPub обвязка**: если требуется переопубликовать мини-приложение на CloudPub после изменения URL, дополнительно выполните команду перезапуска `cloudpub-mini-app`, но только при необходимости:
  ```bash
  docker compose -f docker-compose-arm64.yml restart cloudpub-mini-app
  ```
- **Важно**: остальные сервисы (`api`, `bot`, `postgres` и т. д.) не затрагиваем — команды запускаем только с конкретным именем контейнера.

## Общие принципы
- **Цель документа** — описать последовательный подход к разработке интерфейсов и логики так, чтобы любой разработчик или нейронная модель могла поддерживать в проекте единый стиль «чистого кода».
- **Приоритеты**: читаемость, предсказуемость поведения, повторное использование решений, тестируемость.
- **Золотое правило**: если код трудно объяснить словами за пару минут, его необходимо упростить или декомпозировать.

## Архитектурный подход
- **Декомпозиция всего**: каждый экран делите на мелкие блоки (layout, виджеты, атомарные элементы). Любая сущность, повторяющаяся дважды и более, выносится в отдельный компонент или функцию.
- **Слоистая структура**:
  - уровень представления: UI-компоненты, не содержащие бизнес-логики;
  - уровень композиции: контейнеры, которые собирают UI из атомов и связывают его с логикой;
  - уровень логики: чистые функции и хуки/сервисы, занимающиеся данными и побочными эффектами.
- **Чёткая зона ответственности**: один файл — одна роль (компонент, хук, утилита, константы и т. п.).

## UI-компоненты
- **Универсальные элементы**: кнопки, поля ввода, чекбоксы, селекты и т. д. живут в `src/components/ui`. Они принимают минимально необходимый набор пропсов, поддерживают состояние `disabled`, варианты размеров, визуальные модификаторы.
- **Состояния пустоты**: создавайте отдельные компоненты `EmptyState` с параметрами для текста, описания, иконки и действий. Используйте их в списках, таблицах, карточках.
- **Состояния загрузки/ошибок**: оформляются в отдельные атомы (`Spinner`, `ErrorMessage`) и переиспользуются повсеместно.
- **Контролируемые поля ввода**: поля всегда получают значение и обработчик изменения извне; внутри не должно быть бизнес-логики.
- **Минимум логики**: допускаются только вычисления, относящиеся к отображению (например, форматирование значения). Всё остальное переносится в слой логики.

## Логика и данные
- **Вынос логики**: сложные расчёты, работа с API, обработка событий, фильтрация, сортировка, мемоизация выносятся в отдельные файлы внутри `src/shared/logic` или `src/features/<feature>/logic`.
- **Используйте чистые функции**: без побочных эффектов, принимающие данные через аргументы и возвращающие результат. Это упрощает тестирование и повторное использование.
- **Хуки и сервисы**: бизнес-логику в React оформляйте в хуки (`useSomethingLogic.ts`) или сервисы (`somethingService.ts`). Хук отвечает за связывание данных с React (state, эффекты), сервис — за чистые операции с данными.
- **Константы и конфигурация**: все неизменяемые значения и описания выносите в отдельные файлы (`constants.ts`, `config.ts`). Никаких «магических чисел» в компонентах.

## Организация файлов
- **Структура каталога компонента**:
  - `Component.tsx` — чистый UI;
  - `Component.logic.ts` или `useComponent.ts` — логика;
  - `Component.types.ts` — типы пропсов и интерфейсы;
  - `Component.module.scss` или `Component.styles.ts` — стили;
  - `index.ts` — экспорт наружу.
- **Названия**: следуйте `PascalCase` для компонентов, `camelCase` для функций и переменных, `UPPER_SNAKE_CASE` для констант.
- **Экспорт по умолчанию**: избегайте default-экспортов, чтобы упростить переименования и статический анализ.
- **Относительные пути**: используйте алиасы (`@components`, `@shared`), но внутри одной фичи предпочитайте относительные импорты для прозрачности.

## Стили и верстка
- **БЭМ или CSS-модули**: придерживайтесь единого подхода. В проекте используйте CSS-модули с осмысленными именами классов.
- **Никаких inline-стилей** (кроме динамических, которые невозможно выразить в классах).
- **Переменные темы**: цвета, размеры, шрифты — только через дизайн-токены или CSS-переменные.
- **Адаптив**: компоненты должны корректно работать в заданных брейкпоинтах, переносите размеры и медиаправила в общие файлы.

## Работа с состоянием
- **Локальное состояние**: используйте `useState` и `useReducer` в логических хуках; избегайте хранения данных в компонентах представления.
- **Глобальное состояние**: централизуйте через выбранный стор (Redux, Zustand и т. п.). Избегайте передачи «проп-дриллом».
- **Мемоизация**: применяйте `useMemo` и `useCallback` только при реальной необходимости (узкие места производительности).

## Логика взаимодействия и данные
- **API-вызовы**: оформляются в сервисы (`api/<domain>Service.ts`). UI компоненты получают уже подготовленные данные.
- **Валидация**: выносите в отдельные функции/схемы (например, `validators.ts`). Компонент только вызывает их и показывает результат.
- **Обработка ошибок**: централизуйте в хендлерах, UI лишь отображает сообщение.

## Тестирование
- **Модульные тесты**: обязательны для логических функций и хуков. Обеспечивают корректность чистых операций.
- **Снепшоты**: только для стабильных атомов. Для сложных компонентов пишите тесты, проверяющие поведение.
- **E2E/интеграционные тесты**: для критичных пользовательских сценариев (создание/редактирование сущностей, оплаты и т. п.).
- **Чистота тестов**: один тест — один сценарий. Паттерн Arrange-Act-Assert сохраняйте в каждом файле.

## Документация и пример использования
- **Storybook/Playroom**: у каждого UI-компонента должна быть история с основными состояниями (default, loading, empty, error).
- **README фичи**: описывайте назначение, публичный API, схемы взаимодействия, контракты данных.
- **Диаграммы**: при сложной логике добавляйте блок-схемы или последовательные диаграммы в документацию.

## Ревью и поддержка качества
- **Чеклист перед ревью**:
  - код отформатирован (`prettier`, `eslint`);
  - отсутствуют закомментированные фрагменты и отладочные вызовы;
  - все TODO оформлены задачами в трекере;
  - новые компоненты покрыты примерами/тестами;
  - зависимости обновлены в `package.json` и `pnpm-lock.yaml`/`package-lock.json`.
- **Критерии приёмки ревьюера**:
  - компонент можно понять, пролистав файл сверху вниз без прыжков;
  - логика легко тестируется изолированно;
  - переиспользование компонентов не ломает существующий интерфейс;
  - изменения не нарушают договорённости по архитектуре.

## Работа с PDF «Чистый код»
- **Принципы**: короткие функции, понятные названия, минимальные зависимости, отсутствие дублирования.
- **Практика**: пересматривайте компоненты на предмет долгих файлов, переиспользуйте общий UI, поддерживайте единый стиль именования.
- **Самопроверка**: после завершения задачи перечитайте код и проговорите вслух его назначение. Если чувствуете сложность — возвращайтесь к декомпозиции.

## Процесс разработки
- **Перед началом**: сформулируйте задачу, определите старые и новые компоненты, оцените, чего не хватает в UI-библиотеке проекта.
- **Во время работы**: регулярно выносите повторяющийся код, ведите черновики интерфейсов, не бойтесь разбивать задачи на подзадачи.
- **После завершения**: обновите документацию, добавьте примеры, задокументируйте решение в комментарии к задаче или в `CHANGELOG.md`.

## Коммуникация и знания
- **Общие каналы**: фиксируйте решения и паттерны в Confluence/Notion, доступно описывайте, где какой компонент или сервис используется.
- **Код-ревью**: комментируйте намерения, а не только факты. Если решение принято в обход стандарта, укажите причину и план на будущее.
- **Обучение**: делитесь ссылками на полезные материалы по чистому коду, проводите разборы типичных ошибок, обновляйте этот документ по мере роста команды.

